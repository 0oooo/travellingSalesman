package travellingSalesman;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Set;
import java.util.HashSet;

/**
 * Implementation of the depth first search 
 * @author Camille
 *
 */
public class DFS {

	private AllPaths allPaths; 

	public DFS(int numberOfPaths) {
		allPaths = new AllPaths(); 
	}
	
	private Result finalisePath(Query query) {
		ArrayList<City> finalPath = new ArrayList<City>(query.getPath());
		City firstCity  = query.getPath().get(0);
		finalPath.add(firstCity); 
		
		double finalCost = this.calculateCost(finalPath);
		
		allPaths.addPath(finalPath);
		allPaths.addCost(finalCost);
					
		return new Result(finalCost, finalPath);
	}
	
	private City[] findCitiesToExplore(City[] cities) {
		City[] citiesToExplore = Arrays.copyOf(cities, cities.length - 1);
		for(int city = 0; city < citiesToExplore.length; city++) {
			citiesToExplore[city] = cities[city + 1];
		}
		return citiesToExplore;
	}

	public Result search(Query query) {
		
		double bestCost = 0;
		ArrayList<City> path = query.getPath();
		Set<City> visitedSet = query.getVisited();
		Set<City> available = new HashSet<City>();
		ArrayList<City> bestPath = new ArrayList<City>();
		Set<City> citiesSet = new HashSet<City>(Arrays.asList(query.getCities()));

		// The first time we do the search, no city is visited. We initialise 
		if (query.getVisited().isEmpty()) {
			City[] cities = query.getCities(); 
			path.add(cities[0]);
			
			citiesSet = new HashSet<City>(Arrays.asList(findCitiesToExplore(cities)));
			visitedSet = new HashSet<City>(query.getVisited());
		}
		
		available = citiesSet;
		available.removeAll(visitedSet);
		
		if (available.size() == 0) {
			return finalisePath(query);
		}

		for (City city : available) {
			
			visitedSet.add(city);
			path.add(city);
			
			// Recursively call the search with a copy of the query 
			Query copyQuery = new Query(query.getCities());
			copyQuery.setOverallBest(0).setPath(path).setVisited(visitedSet);
			Result currentResult = search(copyQuery); 

			// if the current path is better update the current best and compare to the overall
			if (bestCost == 0 || currentResult.getBestCost() < bestCost) {
				bestCost = currentResult.getBestCost();
				bestPath = currentResult.getBestPath();

				query.contestOverallBest(bestCost);
			}
			
			// We then go upward the exploratory tree by removing the last cities in path 
			// That allows to create a new path and compare it to the ones we already explored
			visitedSet.remove(city);
			path.remove(path.size() - 1);
		}
		return new Result(bestCost, bestPath);
	}

	public double calculateCost(ArrayList<City> path) {
		double cost = 0;
		for (int city = 1; city < path.size(); city++) {
			cost += path.get(city).calculateDistanceToCity(path.get(city - 1));
		}
		return cost;
	}
	
	/**
	 * For testing purposes, we can print all the paths generated by the dfs
	 * @return AllPaths, a class with: 
	 * - a array of path (arrays of cities)
	 * - an array of costs 
	 */
	public AllPaths getAllPaths() {
		return allPaths;
	}

}

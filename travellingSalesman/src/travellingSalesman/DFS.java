package travellingSalesman;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Set;
import java.util.HashSet;

/**
 * Implementation of the depth first search 
 * @author Camille
 *
 */
public class DFS {

	private AllPaths allPaths; 

	public DFS(int numberOfPaths) {
		allPaths = new AllPaths(numberOfPaths); 
	}
	

	public Result search(Query query) {
					
		Set<City> citiesSet = new HashSet<City>(Arrays.asList(query.getCities()));
		Set<City> visitedSet = query.getVisited();
		ArrayList<City> path = query.getPath();

		// The first time we do the search, no city is visited. We initialise 
		if (query.getVisited().isEmpty()) {
			City[] cities = query.getCities(); 
			path.add(cities[0]);
			
			City[] citiesToExplore = Arrays.copyOf(cities, cities.length - 1);
			for(int city = 0; city < citiesToExplore.length; city++) {
				citiesToExplore[city] = cities[city + 1];
			}
			
			query.setCities(citiesToExplore);
			
			citiesSet = new HashSet<City>(Arrays.asList(citiesToExplore));
			visitedSet = new HashSet<City>(query.getVisited());
		}
		

		Set<City> available = new HashSet<City>();
		available = citiesSet;
		available.removeAll(visitedSet);
		
		if (available.size() == 0) {
						
			ArrayList<City> finalPath = new ArrayList<City>(query.getPath());
			City firstCity  = query.getPath().get(0);
			finalPath.add(firstCity); 
			
			double finalCost = this.calculateCost(finalPath);
			
			allPaths.addPath(finalPath);
			allPaths.addCost(finalCost);
						
			return new Result(finalCost, finalPath);
		}

		double bestCost = 0;
		ArrayList<City> bestPath = new ArrayList<City>();

		for (City city : available) {
			
			visitedSet.add(city);
			path.add(city);
			
			Query copyQuery = new Query(query.getCities());
			copyQuery.setOverallBest(0).setPath(path).setVisited(visitedSet);

			Result currentResult = this.search(copyQuery); //recursion

			// if that path is better, keep it
			if (bestCost == 0 || currentResult.getBestCost() < bestCost) {
				bestCost = currentResult.getBestCost();
				bestPath = currentResult.getBestPath();

				if (query.getOverallBest() == 0 || bestCost < query.getOverallBest()) {
					// found a new best complete path
					query.setOverallBest(bestCost);
				}
			}
			
			visitedSet.remove(city);
			path.remove(path.size() - 1); // remove the last city from the path 
			
			
		}

		return new Result(bestCost, bestPath);
	}

	public double calculateCost(ArrayList<City> path) {
		double cost = 0;
		for (int city = 1; city < path.size(); city++) {
			cost += path.get(city).calculateDistanceToCity(path.get(city - 1));
		}
		return cost;
	}
	
	/**
	 * For testing purposes, we can print all the paths generated by the dfs
	 * @return AllPaths, a class with: 
	 * - a array of path (arrays of cities)
	 * - an array of costs 
	 */
	public AllPaths getAllPaths() {
		return allPaths;
	}

}
